---
title: "DES 加密以及 3DES"
categories: 笔记
tags: [Encryption]
math: true
---


## DES

DES，数据加密标准，即 Data Encryption Standard 一种对称分组加密算法。
其算法被称为 DEA(Data Encryption Algorithm，数据加密算法)。

其算法核心分为两个部分：子密钥生成和数据加解密。

### 子密钥生成

1. **初始密钥处理**：
   - 将 64 位密钥通过 \(PC_1\) 置换表，去掉 8 位校验位（直接舍弃），获得 56 位密钥表示为 \( K' \)。
   ```rust
    const PC1: [usize; 56] = [
        57, 49, 41, 33, 25, 17, 9,
        1,  58, 50, 42, 34, 26, 18,
        10, 2,  59, 51, 43, 35, 27,
        19, 11, 3,  60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,
        7,  62, 54, 46, 38, 30, 22,
        14, 6,  61, 53, 45, 37, 29,
        21, 13, 5,  28, 20, 12, 4
    ];

    fn permute_key_64_to_56(key: u64) -> u64 {
        let mut key_56 = 0;
        for i in 0..56 {
            if key & (1 << (PC1[i] - 1)) != 0 {
                key_56 |= 1 << i;
            }
        }
        key_56
    }
   ```

2. **生成 16 轮子密钥**：
   - 将 \( K' \) 分成左右两部分，每部分 28 位，分别记为 \( C_0 \) 和 \( D_0 \) 。
   - 对于第 \( n \) 轮（\( 1 \leq n \leq 16 \)），对 \( C_{n-1} \) 和 \( D_{n-1} \) 进行左旋移位后得到 \( C_n \) 和 \( D_n \) 。
   - 将 \( C_n \) 和 \( D_n \) 连接起来，形成一个 56 位的字符串，表示为 \( C_nD_n \) 。
   - 对 \( C_nD_n \) 进行 \(PC_2\) 置换，选择其中的 48 位作为第 \( n \) 轮的子密钥 \( K_n \) 。
   ```rust
    const PC2: [u8; 48] = [
        14, 17, 11, 24, 1,  5,
        3,  28, 15, 6,  21, 10,
        23, 19, 12, 4,  26, 8,
        16, 7,  27, 20, 13, 2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32
    ];
    fn subkey_permute(key_56: u64) -> u64 {
        let mut subkey = 0;
        for i in 0..48 {
            if key_56 & (1 << (PC2[i] - 1)) != 0 {
                subkey |= 1 << i;
            }
        }
        subkey
    }
    fn generate_subkeys(key: u64) -> [u64; 16] {
       let mut subkeys = [0; 16];
       let mut c0 = (key >> 28) & 0x0FFFFFFF; // 高28位
       let mut d0 = key & 0x0FFFFFFF; // 低28位
       for i in 0..16 {
           c0 = rotate_left(c0,LEFT_ROTATION_TABLE[i]);
           d0 = rotate_left(d0,LEFT_ROTATION_TABLE[i]);
           let subkey = (c0 << 28) | d0;
           subkeys[i] = subkey_permute(subkey);
       }
       subkeys

    }
    ```

### 数据加解密


1. **初始置换 (IP)**：
   - 将 64 位的明文通过初始置换表 \(IP\) 进行置换，得到新的 64 位数据。
   ```rust
    const IP: [u8; 64] = [
        58, 50, 42, 34, 26, 18, 10, 2,
        60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6,
        64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17, 9,  1,
        59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5,
        63, 55, 47, 39, 31, 23, 15, 7
    ];

    fn initial_permute(text: u64) -> u64 {
       let mut permuted_text = 0;
       for i in 0..64 {
           if text & (1 << (IP[i] - 1)) != 0 {
               permuted_text |= 1 << i;
           }
       }
       permuted_text
    }
   ```

2. **16 轮加密**：
   - 将初始置换后的数据分为左右两部分，每部分 32 位，分别记为 \( L_0 \) 和 \( R_0 \) 。
   - 对于第 \( n \) 轮加密 (\( 1 \leq n \leq 16 \)) ，执行以下操作：
     1. 将 \( R_{n-1} \) 通过扩展置换 \(E\) 扩展为48位，表示为 \( E(R_{n-1}) \) 。
     2. 将 \( E(R_{n-1}) \) 与第 \( n \) 轮的子密钥 \( K_n \) 进行异或操作，得到 48 位的结果。

     > 解密过程中，子密钥 \( K_n \) 的使用顺序与加密过程相反，即 \( K_{16} \) 到 \( K_1 \) 。

     3. 将异或结果通过 S 盒进行替换，得到 32 位的输出。
     4. 将S盒输出通过 P 盒进行置换，得到 32 位的 \( f(R_{n-1}, K_n) \) 。
     5. 计算 \( L_n = R_{n-1} \) 和 \( R_n = L_{n-1} \oplus f(R_{n-1}, K_n) \) 。

3. **最终置换 (FP)**：
   - 将第16轮的输出 \( L_{16} \) 和 \( R_{16} \) 合并，得到 64 位的数据。
   - 将合并后的数据通过最终置换表 FP 进行置换，得到 64 位的密文。
   > 若为解密则得到明文

## 3DES

3DES 即使用三次 DES 加(解)密，相当于用到 3 个密钥
$$
    \begin{aligned}
    C & = E_{K_3}(D_{K_2}(E_{K_1}(P))) \\
    P & = D_{K_1}(E_{K_2}(D_{K_3}(C)))
    \end{aligned}
$$

# ENDING

> 春节将近，顺问冬安


##### 参考资料

1. [DreamGo, (2018). 数据加密算法--详解DES加密算法原理与实现.](https://www.cnblogs.com/idreamo/p/9333753.html)
2. [维基百科, (2024). 資料加密標準.](https://zh.wikipedia.org/w/index.php?title=%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96&oldid=84362774)
